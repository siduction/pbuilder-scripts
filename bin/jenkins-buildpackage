#!/bin/bash
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

## usage
usage()
{
cat << EOF
jenkins-buildpackage
usage: $0 options

OPTIONS:
    -h  Show this message
    -a  Architecture, should be 'i386' or 'amd64'
    -r  Repository: base, fixes, extra, kdenext, lxqt, razorqt, xfcenext
    -d  Distribution: unstable, next, experimental, sid
    -x  Delete file for failed builds
    -V  Version
EOF
}

## version
version() {
    . /usr/share/pbuilder-scripts/version
    echo "$(basename $0): ${VERSION}"
}

## get basic configuration form /etc/jenkins
if [ -f /etc/jenkins/jenkins-buildpackage.conf ]; then
    echo -e "Configuration: /etc/jenkins/jenkins-buildpackage.conf used"
    . /etc/jenkins/jenkins-buildpackage.conf
fi

## get user conf
if [ -f ${HOME}/.config/jenkins/jenkins-buildpackage.conf ]; then
    echo -e "Configuration: ${HOME}/.config/jenkins-buildpackage.conf  used"
    . ${HOME}/.config/jenkins/jenkins-builpackage.conf
fi

## option handling
while getopts “a:r:d:Vhx” OPTION; do
    case ${OPTION} in
        a)
            ARCH=${OPTARG}
            ;;
        r)
            REPOSITORY=${OPTARG}
            ;;
        d)
            DISTRI=${OPTARG}
            ;;
        h)
            usage
            exit 0
            ;;
        x)
            DELETE_FAILED="true"
            ;;
        V)
            version
            exit 0
            ;;
     esac
done

# really dirty - serverside base is defined fugly as can be for now
REPOBASE="/var/www/virtual/packages/${REPOSITORY}"


## is_valid_line
is_valid_line() {
    [[ ! -e ${SOURCEPATH}/build-failed-${REPOSITORY}-${DISTRI}-${ARCH} ]] && touch ${SOURCEPATH}/build-failed-${REPOSITORY}-${DISTRI}-${ARCH}
    grep "$REPOLINE" ${SOURCEPATH}/build-failed-${REPOSITORY}-${DISTRI}-${ARCH}
    RESULT=$?
    case $RESULT in
        1)
            echo -e "Valid: $REPOLINE"
            ;;
        0)
            echo -e "Faulty: $REPOLINE"
            ;;
    esac
    return $RESULT
}


## sub split repo_line
split_repo_line() {
    PACKAGE_NAME=$(echo $REPOLINE | awk -F' ' '{ print $1 }')
    PACKAGE_VER=$(echo $REPOLINE | awk -F' ' '{ print $2 }')
    PACKAGE_DSC=$(echo $REPOLINE | awk -F' ' '{ print $3 }')
    PACKAGE_FILES=$(echo $PACKAGE_DSC | sed 's/\.dsc/*/')
    SOURCEDIR=$SOURCEPATH/$PACKAGE_NAME-$PACKAGE_VER
    BUILD_DSC=$(basename $PACKAGE_DSC)
    UPLOADFILES=$(basename $PACKAGE_FILES)
}

## get_source_package
get_source_package() {
    [[ -d ${SOURCEDIR} ]] && rm -rv ${SOURCEDIR}
    mkdir -p ${SOURCEDIR}
    pushd ${SOURCEDIR}
    echo "HOST:         $HOST"
    echo "REPOLINE:     $REPOLINE"
    echo "PACKAGE_DSC:  $PACKAGE_DSC"
    dget -d ${PROTOCOL}${HOST}/${REPOSITORY}/${PACKAGE_DSC}
    popd
}

## build_source_package
build_source_package() {
    pushd $SOURCEDIR
    case $ARCH in
        all)
            BUILDARCH='amd64'
            ;;
        *)
            BUILDARCH=$ARCH
            ;;
    esac
    BUILDTARGET="/var/cache/pbuilder/${DISTRI}-${BUILDARCH}/result"
    pbuild -a $BUILDARCH -r $DISTRI  $BUILD_DSC
    RESULT=$?
    echo -e "build_source_package Result: ${RESULT}"
    popd
    if [ $RESULT -ne "0" ]; then
        if [ "${FAILED}" != "true" ]; then
            write_failed
           FAILED="true"
        fi
    else
        rm -rf ${SOURCEDIR}
    fi
}

## upload_package
upload_package() {
    pushd $BUILDTARGET
    dput  $REPOSITORY ${UPLOADFILES}changes
    RESULT=$?
    echo -e "upload_package Result: ${RESULT}"
    if [ $RESULT -ne "0" ]; then
        if [ "${FAILED}" != "true" ]; then
            write_failed
            FAILED="true"
        fi
    fi
    echo -e "---- Upload Dir: Cleanup ----"
    rm -fv $UPLOADFILES
    popd
}

## delete failed builds file
delete_failed() {
    rm -fv  ${SOURCEPATH}/build-failed-${REPOSITORY}-${DISTRI}-${ARCH}
}

## write_failed
write_failed() {
    echo ${REPOLINE} >>  ${SOURCEPATH}/build-failed-${REPOSITORY}-${DISTRI}-${ARCH}
    echo -e "added ${REPOLINE} to failed builds for ${REPOSITORY}, ${DISTRI} and ${ARCH} \n"
}

## Main
[ "${DELETE_FAILED}" = "true" ] && delete_failed && exit 0
[ ! -d ${SOURCEPATH} ] && mkdir -p ${SOURCEPATH} && echo ${SOURCEPATH}
IFS=$'\n'
for i in $(ssh ${USER}@${HOST}  "cd ${REPOBASE}; reprepro build-needing $DISTRI  $ARCH"); do
    REPOLINE=$i
    is_valid_line
    [ "$?" -ne "1" ] && continue
    split_repo_line
    get_source_package
    FAILED=""
    build_source_package
    if [ ${RESULT} -eq "0" ]; then
        upload_package
    fi
    break
done

echo -e "main buildresult: ${RESULT}"
exit ${RESULT}
