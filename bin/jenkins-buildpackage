#!/bin/bash
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

## usage
usage()
{
cat << EOF
jenkins-buildpackage
usage: $0 options


OPTIONS:
   -h      Show this message
   -a      Architecture, should be 'i386' or 'amd64'
   -r      Repository: base, fixes, extra, kdenext, lxqt, razorqt, xfcenext
   -d      Distribution: unstable, next, experimental, sid
   -x      Delete file for failed builds
   -V      Version
EOF
}

## version
version() {
    . /usr/share/pbuilder-scripts/version
    echo "$(basename $0): ${VERSION}"
}

## get basic configuration form /etc/jenkins
if [ -f /etc/jenkins/jenkins-buildpackage.conf ]; then
    echo -e "Configuration: /etc/jenkins/jenkins-buildpackage.conf used"
    . /etc/jenkins/jenkins-buildpackage.conf
fi

## get user conf
if [ -f ${HOME}/.config/jenkins/jenkins-buildpackage.conf ]; then
    echo -e "Configuration: ${HOME}/.config/jenkins-buildpackage.conf  used"
    . ${HOME}/.config/jenkins/jenkins-builpackage.conf
fi

## option handling
while getopts “a:r:d:Vhx” OPTION; do
     case ${OPTION} in
         a)
             ARCH=${OPTARG}
             ;;
         r)
             REPO=${OPTARG}
             ;;
         d)
             DISTRI=${OPTARG}
             ;;
         h)
             usage
             exit 0
             ;;
         x)
             DELETE_FAILED="true"
             ;;
         V)
             version
             exit 0
             ;;
     esac
done

# really dirty - serverside base is defined fugly as can be for now
REPOBASE="/var/www/virtual/packages/${REPO}"
BUILDTARGET="/var/cache/pbuilder/${DISTRI}-${ARCH}/result"


## is_valid_line
is_valid_line() {
    [[ ! -e ${SOURCEPATH}/build-failed-${REPO}-${DISTRI}-${ARCH} ]] && touch ${SOURCEPATH}/build-failed-${REPO}-${DISTRI}-${ARCH}
    grep "$REPOLINE" ${SOURCEPATH}/build-failed-${REPO}-${DISTRI}-${ARCH}
    RESULT=$?
    case $RESULT in
        1)
             echo -e "Valid: $REPOLINE"
        ;;
        0)
             echo -e "Faulty: $REPOLINE"
        ;;
    esac
    return $RESULT
}


## sub split repo_line
split_repo_line() {
    PACKAGE_NAME=$(echo $REPOLINE | awk -F' ' '{ print $1 }')
    PACKAGE_VER=$(echo $REPOLINE | awk -F' ' '{ print $2 }')
    PACKAGE_DSC=$(echo $REPOLINE | awk -F' ' '{ print $3 }')
    PACKAGE_FILES=$(echo $PACKAGE_DSC | sed 's/\.dsc/*/')
    SOURCEDIR=$SOURCEPATH/$PACKAGE_NAME-$PACKAGE_VER
    BUILD_DSC=$(basename $PACKAGE_DSC)
    UPLOADFILES=$(basename $PACKAGE_FILES)
}

## get_source_package
get_source_package() {
    [[ -d $SOURCEDIR ]] && rm -rv $SOURCEDIR
    mkdir -p $SOURCEDIR
    pushd $SOURCEDIR
    scp  ${USER}@${HOST}:$REPOBASE/$PACKAGE_FILES .
    popd
}

## build_source_package
build_source_package() {
   pushd $SOURCEDIR
   pbuild -a $ARCH -r $DISTRI  $BUILD_DSC
   RESULT=$?
   echo -e "build_source_package Result: ${RESULT}"
   popd
   if [ $RESULT -ne "0" ]; then
       if [ $FAILED != "true" then
          write_failed
          FAILED="true"
       fi
   else
       rm -rf ${SOURCEDIR}
   fi
}

## sign_builded_packages
sign_builded_packages() {
    debsign -k 53CD5927 ${BUILDTARGET}/${UPLOADFILES}changes
    RESULT=$?
    echo -e "sign_package Result: ${RESULT}"
    if [ $RESULT -ne "0" ]; then
       if [ $FAILED != "true" then
          write_failed
          FAILED="true"
       fi
    fi
}

## upload_package
upload_package() {
    pushd $BUILDTARGET
    dput  $REPO ${UPLOADFILES}changes
    RESULT=$?
    echo -e "upload_package Result: ${RESULT}"
    if [ $RESULT -ne "0" ]; then
       if [ $FAILED != "true" then
          write_failed
          FAILED="true"
       fi
    fi

    rm $UPLOADFILES
    popd
}

## delete failed builds file
delete_failed() {
    rm -fv  ${SOURCEPATH}/build-failed-${REPO}-${DISTRI}-${ARCH}
}


## write_failed
write_failed() {
   echo ${REPOLINE} >>  ${SOURCEPATH}/build-failed-${REPO}-${DISTRI}-${ARCH}
   echo -e "added ${REPOLINE} to failed builds for ${REPO}, ${DISTRI} and ${ARCH} \n"
}



## Main
[ "${DELETE_FAILED}" = "true" ] && delete_failed && exit 0
[ ! -d ${SOURCEPATH} ] && mkdir -p ${SOURCEPATH} && echo ${SOURCEPATH}
IFS=$'\n'
for i in $(ssh ${USER}@${HOST}  "cd ${REPOBASE}; reprepro build-needing $DISTRI  $ARCH"); do
    REPOLINE=$i
    is_valid_line
    [ "$?" -ne "1" ] && continue
    split_repo_line
    get_source_package
    FAILED=""
    build_source_package
    sign_builded_packages
    echo "main buildresult: $?"
    upload_package
   break
done
